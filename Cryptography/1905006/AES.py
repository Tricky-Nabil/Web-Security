import math
import random
import datetime
import codecs
import binascii

from BitVector import *

# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""

#!pip install BitVector


"""Tables"""


Sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Mixer = [
    [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
    [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
]

InvMixer = [
    [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
    [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
    [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
    [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
]


AES_modulus = BitVector(bitstring='100011011')



def add_round_constant(temp , k):
    for i in range(4):
        temp[i] = temp[i] ^ round_constant[k][i]
        #print(hex(temp[i]) , end = ' ')
    return temp

def substitute_byte(temp_round):
    #print(temp_round)
    #print(hex(Sbox[32]))
    for i in range(4):
        temp_round[i] = Sbox[temp_round[i]]
    return temp_round

def make_int(temp_round):
    for i in range(4):
        for j in range(4):
            temp_round[i][j] = int(temp_round[i][j] , 16)
    return temp_round

def circular_left_shift(w_last):
    #print(w_last)
    first_temp = w_last[0]
    for i in range(3):
        w_last[i] = w_last[i+1]
    w_last[3] = first_temp
    #print(w_last)
    return w_last
        
def print_keys(keys):
    #print(keys)
    for i in range (len(keys)):
        for j in range (4):
            for k in range(4):
                print(hex(keys[i][j][k]) , end = " ")
        print()
def make_other_keys(round_keys):
    #print(len(round_keys))
    #print(round_keys)
    for i in range(10):
        w0 = round_keys[i][0][0:4]
        w1 = round_keys[i][1][0:4]
        w2 = round_keys[i][2][0:4]
        w3 = round_keys[i][3][0:4]

        w_new = w3[0:4]
        w_new = circular_left_shift(w_new)
        w_new = substitute_byte(w_new)
        w_new = add_round_constant(w_new , i)
        
        for j in range (4):
            w0[j] = w0[j] ^ w_new[j]
        
        for j in range(4):
            w1[j] = w1[j] ^ w0[j]
    
        for j in range (4):
            w2[j] = w2[j] ^ w1[j]
        
        for j in range(4):
            w3[j] = w3[j] ^ w2[j]
        
        temp = []
       
        temp.append(w0) 
        temp.append(w1)
        temp.append(w2)
        temp.append(w3)
        round_keys.append(temp)

def make_first_round_key(key : str):
    #print(key)
    append_set = []
    temp_round = []
    for i in range(0 , len(key) + 1 , 2):
        
        if i % 8 == 0 and i != 0:
            temp_round.append(append_set)
            append_set = []
        
        if(i >= len(key) + 1):
            break
        append_set.append(key[i:i+2])
       
    make_int(temp_round)
    round_keys.append(temp_round)
    
    make_other_keys(round_keys)
    #print_keys()
    

def make_round_keys_col_major():
    for i in range(11):
        temp = []
        for j in range(4):
            temp.append([])
        round_keys_column_major.append(temp)
    #print(round_keys_column_major)
    for i in range(11):
        for j in range(4):
            for k in range(4):
                round_keys_column_major[i][j].append(round_keys[i][k][j])


def make_plain_text_column_major(key : str , col_major_plain_text):
    append_set = []
    temp_round = []
    row_major_plain_text = []
    
    for i in range(0 , len(key) + 1 , 2):
        
        if i % 8 == 0 and i != 0:
            temp_round.append(append_set)
            append_set = []
        
        if(i >= len(key) + 1):
            break
        append_set.append(key[i:i+2])
       
    make_int(temp_round)
    row_major_plain_text.append(temp_round)

    #print_keys(row_major_plain_text)

    for i in range(4):
        for j in range(4):
            col_major_plain_text[0][i].append(row_major_plain_text[0][j][i])
    return col_major_plain_text

    #print_keys(col_major_plain_text)
def print_state_matrixes(st):
    #print(len(st))
    for i in range(len(st)):
        for j in range(4):
            print(hex(st[i][j]) , end = " ")
        print()



def addkey_round0(col_major_plain_text):
    state_matrix_0 = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    for i in range(4):
        state_matrix_0.append([])
    #print(state_matrix_0)
    for i in range(4):
        for j in range(4):
            state_matrix_0[i][j] = round_keys_column_major[0][i][j] ^ col_major_plain_text[0][i][j]
    #print(state_matrix_0)
    # print_state_matrixes(round_keys_column_major[0])
    # print_keys(col_major_plain_text)
    # print("after 0 round - ")
    # print_state_matrixes(state_matrix_0)
    return state_matrix_0
def row1_left_shift(matrix):
    temp = matrix[1][0]
    for i in range(3):
        matrix[1][i] = matrix[1][i+1]
    matrix[1][3] = temp
    return matrix

def row2_left_shift(matrix):
    temp1 = matrix[2][0]
    temp2 = matrix[2][1]
    matrix[2][0] = matrix[2][2]
    matrix[2][1] = matrix[2][3]
    matrix[2][2] = temp1
    matrix[2][3] = temp2
    return matrix

def row3_left_shift(matrix):
    temp = matrix[3][3]
    for i in reversed(range(3)):
        matrix[3][i+1] = matrix[3][i]
    matrix[3][0] = temp 
    return matrix 

def row1_right_shift(matrix):
    temp = matrix[1][3]
    for i in reversed(range(3)):
        matrix[1][i+1] = matrix[1][i]
    matrix[1][0] = temp 
    return matrix

def row2_right_shift(matrix):
    temp1 = matrix[2][2]
    temp2 = matrix[2][3]
    matrix[2][2] = matrix[2][0]
    matrix[2][3] = matrix[2][1]
    matrix[2][0] = temp1
    matrix[2][1] = temp2
    return matrix

def row3_right_shift(matrix):
    temp = matrix[3][0]
    for i in range(3):
        matrix[3][i] = matrix[3][i+1]
    matrix[3][3] = temp
    return matrix

def mix_column(matrix):
    new_matrix = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    for i in range(0, 4): 
        for j in range(0, 4): 
            temp_int = 0
            for k in range(0, 4): 
                bv1 = BitVector(intVal = matrix[k][j])
                temp_int ^= (Mixer[i][k].gf_multiply_modular(bv1, AES_modulus, 8)).intValue()  
            new_matrix[i][j] = temp_int
    return new_matrix

def inverse_mix_colm(matrix):
    new_matrix = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    for i in range(0, 4): 
        for j in range(0, 4): 
            temp_int = 0
            for k in range(0, 4): 
                bv1 = BitVector(intVal = matrix[k][j])
                temp_int ^= (InvMixer[i][k].gf_multiply_modular(bv1, AES_modulus, 8)).intValue()
            new_matrix[i][j] = temp_int
    return new_matrix

def main_body_of_encryption(first_state_matrix):

    temp = first_state_matrix.copy()
    cnt = 1
    
    for round_no in range(10):
        #substitute

        for i in range(4):
            for j in range(4):
                temp[i][j] = Sbox[temp[i][j]]
    # print_state_matrixes(temp)
    #row shift
        temp = row1_left_shift(temp)
        temp = row2_left_shift(temp)
        temp = row3_left_shift(temp)
    #print_state_matrixes(temp)

    #mix column
        if round_no != 9:
            temp = mix_column(temp)
    #print_state_matrixes(temp)
    #add round key
        
        for i in range(4):
            for j in range(4):
                temp[i][j] = temp[i][j] ^ round_keys_column_major[cnt][i][j]
        
        #print(f'After round {cnt} - ')

        cnt = cnt + 1
    return temp

def aes_encryption(plain_text , key_text):
    # for i in range(16):
    #     plain_text = "\0" + plain_text
    plain_text = adjust_input(plain_text)  # padding
    
    #print(plain_text)

    hexadecimal_representation_of_key_text = key_text.encode("utf-8").hex()
    hexadecimal_representation_of_plain_text = plain_text.encode("utf-8").hex()

    # print(len(hexadecimal_representation_of_plain_text))
    #print(hexadecimal_representation_of_plain_text)
    st = datetime.datetime.now()
    make_first_round_key(hexadecimal_representation_of_key_text)
    make_round_keys_col_major()
    et = datetime.datetime.now()
    key_scheduling_time = (et-st).microseconds / 1000
    # for i in range(len(round_keys_column_major)):
    #     print_1d_colm_major(round_keys_column_major[i])

    temp_immediate_vector = make_immediate_vector()
    immediate_vector.append(temp_immediate_vector.copy())

    final_cipher_for_server = ""
    final_cipher_ascii = ""

    for i in range(0 , len(hexadecimal_representation_of_plain_text) , 32):
        col_major_plain_text = [[[] , [] , [] , []]]
        # for l in range(len(immediate_vector)):
        #     print_1d_colm_major(immediate_vector[l])
        #print(col_major_plain_text)
        col_major_plain_text = make_plain_text_column_major(hexadecimal_representation_of_plain_text[i : i + 32] , col_major_plain_text)
        #print(hexadecimal_representation_of_plain_text[i : i + 32])
        #print_1d_colm_major(col_major_plain_text[0])
        # print(f'Immedeiate vector {i//32} - ')
        # print_1d_colm_major(immediate_vector[i//32])
        col_major_plain_text = update_colm_major_plain_text(col_major_plain_text , immediate_vector , i//32)

        # print(f'Col major vector {i//32} - ')
        # print_1d_colm_major(col_major_plain_text[0])


        #print_1d_colm_major(col_major_plain_text[0])

        state_mat0 = addkey_round0(col_major_plain_text)
        cipher = main_body_of_encryption(state_mat0)

        immediate_vector.append(cipher)

        #print_1d_colm_major(cipher)

        # print("Cipher ")
        # print_1d_colm_major(cipher)

        # print(f'Immediate Vector {i//32 + 1} no')
        # print_1d_colm_major(immediate_vector[i//32 + 1])

        
        final_cipher_for_server+= make_formatted_output(cipher)
        final_cipher_ascii+= make_ascii(cipher)

    # print(final_cipher_for_server)
    # for i in range(len(immediate_vector)):
    #     print_1d_colm_major(immediate_vector[i])
    return final_cipher_for_server , final_cipher_ascii , key_scheduling_time


def main_body_of_decryption(matrix):
    #print_state_matrixes(matrix)
    temp = matrix.copy()
    cnt = 9
    for round_no in range(10):

        #inverse shift row

        temp = row1_right_shift(temp)
        temp = row2_right_shift(temp)
        temp = row3_right_shift(temp)


        #inverse sub byte
        for i in range(4):
            for j in range(4):
                temp[i][j] = InvSbox[temp[i][j]]

        # print("after sub byte-")
        # print_state_matrixes(temp)

        #add round key
        for i in range(4):
            for j in range(4):
                temp[i][j] ^= round_keys_column_major[cnt][i][j]
        #print(cnt)
        cnt = cnt - 1
        #print(cnt)
        #print_state_matrixes(temp)

        #inverse mix colm
        if(round_no != 9):
            temp = inverse_mix_colm(temp)

        
    return temp


def initial_decryption(matrix):
    for i in range(4):
        for j in range(4):
            matrix[i][j] = matrix[i][j] ^ round_keys_column_major[10][i][j]
    return matrix

def make_cipher_vector_from_cipher(cipher : str):
    #immediate_vector = []
    #print(len(immediate_vector))
    temp_cipher = []
    for i in range(0 , len(cipher) , 32):
        temp = [[], [] , [] , []]
        k = 0
        for j in range(i , i+32 , 2):
            temp[k].append(cipher[j:j+2])
            k = (k+1) % 4
        temp_cipher.append(temp)
    #print("Making Cipher vector from cipher text - ")
    # print(len(temp_cipher))
    # print(temp_cipher)
    # for i in range(len(temp_cipher)):
    #     print_1d_colm_major(temp_cipher[i])
    # print("Printed Cipher text")
    for i in range(len(temp_cipher)):
        for j in range(4):
            for k in range(4):
                temp_cipher[i][j][k] = int(temp_cipher[i][j][k] , 16)
    # for i in range(len(temp_cipher)):
    #     print_1d_colm_major(temp_cipher[i])

    # print("ENdinf")
    return temp_cipher

def make_final_dipher_for_receiver(dipher , IV):
    for i in range(4):
        for j in range(4):
            dipher[i][j] ^= IV[i][j]
    return dipher

def aes_decryption(cipher : str, key_text) -> str:
    
    IV = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    # hexadecimal_representation_of_key_text = key_text.encode("utf-8").hex()
    #hexadecimal_representation_of_plain_text = plain_text.encode("utf-8").hex()
    # make_first_round_key(hexadecimal_representation_of_key_text)
    # make_round_keys_col_major()
    round_keys.clear()
    st = datetime.datetime.now()
    hexadecimal_representation_of_key_text = key_text.encode("utf-8").hex()
    make_first_round_key(hexadecimal_representation_of_key_text)
    make_round_keys_col_major()
    et = datetime.datetime.now()
    key_scheduling_time = (et-st).microseconds / 1000

    cipher = cipher.replace(" " , "")
    final_dipher = ""
    final_dipher_ascii = ""
    #print(cipher)
    cipher_vector = make_cipher_vector_from_cipher(cipher)

    # print("Printing cipher vector")
    # for i in range(2):
    #     print_1d_colm_major(cipher_vector[i])
    # print("Cyper end")
    # for i in range(len(immediate_vector)):
    #     for j in range(4):
    #         for k in range(4):
    #             print(immediate_vector[i][j][k] , end = " ")
    
    #print(len(immediate_vector))
    cipher_matrix = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    for i in range(len(cipher_vector)):
        #cipher_matrix = cipher_vector[i]
        
        # print("Cipher")
        # print_1d_colm_major(cipher_matrix)
        # print("Immediate")
        # print_1d_colm_major(immediate_vector[i+1])
        for j in range(4):
            for k in range(4):
                cipher_matrix[j][k] = cipher_vector[i][j][k]
        #         print(type(cipher_matrix[j][k]))
        # print(cipher_matrix)
        # print("printing cipher matrix")
        # print_1d_colm_major(cipher_matrix)

        temp = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
        for p in range(4):
            for q in range(4):
                temp[p][q] = cipher_matrix[p][q]

        #temp[0][0] = 1
        decryted_data_initial = initial_decryption(temp)
        # print("Printing after first decryption - ")
        # print_1d_colm_major(cipher_matrix)
        dipher_without_immediate_vector = main_body_of_decryption(decryted_data_initial)

        #print(i)

        dipher = make_final_dipher_for_receiver(dipher_without_immediate_vector , IV)
        for p in range(4):
            for q in range(4):
                IV[p][q] = cipher_matrix[p][q]
        # print("printing cipher matrix again")
        # print_1d_colm_major(cipher_matrix)
        # print("printing IV matrix")
        # print_1d_colm_major(IV)
        
        
        final_dipher+= make_formatted_output(dipher)

        final_dipher_ascii+= make_ascii(dipher_without_immediate_vector)
    # print("Decryption")
    # print(hexadecimal_representation_of_plain_text)
    # print(final_dipher_ascii)
    return final_dipher , final_dipher_ascii , key_scheduling_time

    # for i in range(len(immediate_vector)):
    #     for j in range(4):
    #         for k in range(4):
    #             print(immediate_vector[i][j][k] , end = " ")
    #         print()

    #print(len(immediate_vector))


def print_1d_matrix(matrix):
    for i in range(4):
        for j in range(4):
            print(hex(matrix[i][j]) , end = " ")
    print()


def adjust_input(plain_text : str):
    if len(plain_text) % 16 != 0:
        lower_bound_of_plain_text = math.floor(len(plain_text) / 16)
        upper_bound_of_plain_text = math.ceil(len(plain_text) / 16)
        for i in range(16 * upper_bound_of_plain_text - len(plain_text)):
            plain_text += "\0"
    return plain_text


def make_output_format_of_text(text : str):
    temp_str = ""
    for i in range(0,len(text),2):
        temp_str+= text[i:i+2] + " "
    return temp_str

def make_formatted_output(matrix):
    temp_str = ""
    for i in range(4):
        for j in range(4):
            temp_str+= (hex(matrix[j][i])[2:] + " ") if (len(hex(matrix[j][i])[2:]) == 2) else ("0"+hex(matrix[j][i])[2:] + " ")
    return temp_str

def print_1d_colm_major(matrix):
    for i in range(4):
        for j in range(4):
            print(hex(matrix[j][i]) , end = " ")
    print()

def make_immediate_vector():
    temp = [[0,0,0,0] , [0,0,0,0] , [0,0,0,0] , [0,0,0,0]]
    # for i in range(4):
    #     for j in range(4):
    #         a = random.randint(1 , 100)
    #         temp[i][j] = a
    return temp

def update_colm_major_plain_text(col_maj_plain_text , immediate_vec , index):

    for i in range(4):
        for j in range(4):
            #print(col_maj_plain_text[0][i][j] , immediate_vec[index][i][j] , sep=',')
            col_maj_plain_text[0][i][j] ^= immediate_vec[index][i][j]
            #print(col_maj_plain_text[0][i][j])
    return col_maj_plain_text

def make_final_dipher(dipher , immediate_vector , index):
    for i in range(4):
        for j in range(4):
            dipher[i][j] ^= immediate_vector[index][i][j]
    return dipher

def make_ascii(matrix):
    temp_str = ""
    for i in range(4):
        for j in range(4):
            temp_str+= chr(matrix[j][i])
    return temp_str

round_keys = []
round_constant = [[1 , 0 , 0 , 0] , [2 , 0 , 0 , 0] , [4 , 0 , 0 , 0] , [8 , 0 , 0 , 0] , [16 , 0 , 0 , 0] , [32 , 0 , 0, 0] , [64 , 0 , 0 , 0], [128 , 0 , 0 , 0] , [27 , 0 , 0 , 0] , [54 , 0 , 0 , 0]]
round_keys_column_major = []
immediate_vector = []
final_dipher = ""
final_cipher = ""
key_text_hex_format = ""
plain_text_hex_format = ""
final_cipher_ascii = ""
final_dipher_ascii = ""
#key_scheduling_time = 0
encryption_time = 0
decryption_time = 0


# cipher_text = aes_encryption("Never Gonna Give you up" , "BUET CSE19 Batch")

# aes_decryption(cipher_text , "BUET CSE19 Batch")

def showRuntime():
    key_text = "BUET CSE19 Batch"
    plain_text = "Never Gonna Give you up"

    st = datetime.datetime.now()
    cipher_text , cipher_ascii , key_scheduling_time = aes_encryption(plain_text , key_text)
    et = datetime.datetime.now()

    encryption_time = ((et - st).microseconds / 1000 - key_scheduling_time)

    st = datetime.datetime.now()
    dipher_text , dipher_ascii , key_scheduling_time = aes_decryption(cipher_text , key_text)

    et = datetime.datetime.now()

    decryption_time = ((et - st).microseconds / 1000 - key_scheduling_time)

    hexadecimal_representation_of_plain_text = plain_text.encode("utf-8").hex()
    hexadecimal_representation_of_key_text = key_text.encode("utf-8").hex()
    print("Key:")
    print("In ASCII: " + key_text)
    print("In HEX: " + make_output_format_of_text(hexadecimal_representation_of_key_text))
    print()

    print("Plain Text:")
    print("In ASCII: " + plain_text)
    print("In HEX: " + make_output_format_of_text(hexadecimal_representation_of_plain_text))
    print()


    print("Ciphered Text : ")
    print("In HEX: " + cipher_text)
    print("In ASCII : " + cipher_ascii)
    print()

    print("Deciphered Text : ")
    print("In HEX: " + dipher_text)
    print("In ASCII : " + dipher_ascii)
    print()

    print("Execution Time Details: ")
    print(f'Key Schedule Time: {key_scheduling_time} ms')
    print(f'Encrytion Time: {encryption_time} ms')
    print(f'Decryption Time: {decryption_time} ms')
    print()

#showRuntime()

# #key_text = "Thats my Kung Fu"
# key_text = "BUET CSE19 Batch"

# #plain_text = "Two One Nine Two"
# plain_text = "Never Gonna Give you up"

# plain_text = adjust_input(plain_text)

# hexadecimal_representation_of_key_text = key_text.encode("utf-8").hex()
# hexadecimal_representation_of_plain_text = plain_text.encode("utf-8").hex()

# #round keys

# start_time = datetime.datetime.now()
# make_first_round_key(hexadecimal_representation_of_key_text)
# make_round_keys_col_major()
# end_time = datetime.datetime.now()

# key_scheduling_time = (end_time - start_time).microseconds / 1000

# #print(key_scheduling_time)
# temp_immediate_vector = make_immediate_vector()
# immediate_vector.append(temp_immediate_vector.copy())




# for i in range(0 , len(hexadecimal_representation_of_plain_text) , 32):
#     print("Printing Immediate Vector : ")
#     for l in range(len(immediate_vector)):
#         print_1d_colm_major(immediate_vector[l])
#     print()
#     col_major_plain_text = [[[] , [] , [] , []]]
#     col_major_plain_text = make_plain_text_column_major(hexadecimal_representation_of_plain_text[i : i + 32] , col_major_plain_text)
#     print("plain text")
#     print_1d_colm_major(col_major_plain_text[0])
#     #print(f'immediate vector')
#     print_1d_colm_major(immediate_vector[i//32])
#     col_major_plain_text = update_colm_major_plain_text(col_major_plain_text , immediate_vector , math.floor(i/32))
#     print("After xor ")
#     print_1d_colm_major(col_major_plain_text[0])

# #encryption

#     st = datetime.datetime.now()
#     state_mat0 = addkey_round0(col_major_plain_text)
#     cipher = main_body_of_encryption(state_mat0)
#     et = datetime.datetime.now()

#     print(f'{i//32 + 1} no  cipher')
#     print_1d_colm_major(cipher)
#     encryption_time+= (et - st).microseconds / 1000

#     a = cipher.copy()
#     print("a")
#     print_1d_colm_major(a)
#     immediate_vector.append(cipher)
#     final_cipher+= make_formatted_output(cipher)

#     final_cipher_ascii+= make_ascii(cipher)
 
# #decryption

#     st = datetime.datetime.now()

#     decryted_data_initial = initial_decryption(cipher)
#     dipher_without_immediate_vector = main_body_of_decryption(decryted_data_initial)

#     dipher = make_final_dipher(dipher_without_immediate_vector , immediate_vector , math.floor(i/32))
#     et = datetime.datetime.now()

#     decryption_time+= (et - st).microseconds / 1000
#     final_dipher+= make_formatted_output(dipher)

#     final_dipher_ascii+= make_ascii(dipher)


